############################################
## Author: Daniel John Lawson dan.lawson@bristol.ac.uk
## Date: 1 Sept 2023
## Licence: GPLv3
##
############################################
############################################
## This script generates Extended Data Figure 2
## It also generates Main Data Figure 2 (bottom)
## This script takes as input the per-individual ancestry estimates generated by our pipeline
## And the definition of each of the populations that we wish to report ancestry information for
## Which is a summary of the potential available list of populations that inference was run against.
## It then summarises this information into map format for visualisation
## It uses birth location of UKBB participants, as well as individual-level ancestry profiles, which are not possible to share.

##########
## Libraries
library("dplyr") # For %>% notation
library(rworldmap) # For `getMap`
library(stringdist) # For matching rworldmap locations to our regions
library(TeachingDemos) # For subplot
library("lhs") # Random positions in a latin hypercube, fol color palettes

############################################
############################################
## Function Definitions
########################
matColSums<-function(mat,poplist)
## Sums over columns in a matrix, by grouping all columns listed in poplist
## e.g. if mat is M*N matrix and poplist is length K, returns a M*K matrix
## the names of poplist are used to assign names to the returned matrix
{
        res<-matrix(0,nrow=dim(mat)[1],ncol=length(poplist))
        colindex<-lapply(poplist,function(x){which(colnames(mat)%in%x)})
        res<-t(apply(mat,1,function(x){
                sapply(colindex,function(y){sum(x[y])})
        }))
#        if(dim(res)[1]==1) res<-t(res)
        colnames(res)<-names(poplist)
        rownames(res)<-rownames(mat)
        res
}
matColMeans<-function(mat,poplist)
## Sums over columns in a matrix, by grouping all columns listed in poplist
## e.g. if mat is M*N matrix and poplist is length K, returns a M*K matrix
## the names of poplist are used to assign names to the returned matrix
{
        res<-matrix(0,nrow=dim(mat)[1],ncol=length(poplist))
        colindex<-lapply(poplist,function(x){which(colnames(mat)%in%x)})
        res<-t(apply(mat,1,function(x){
                sapply(colindex,function(y){mean(x[y])})
        }))
        colnames(res)<-names(poplist)
        rownames(res)<-rownames(mat)
        res
}
orderByHclust<-function(tm){
    thc=as.dendrogram(hclust(dist(tm)))
    thc=reorder(thc,rowSums(tm%*%t(tm)))
    return(rev(labels(thc)))
}

dobarplot<-function(country,cex.text=1,cex.main=1,labelmin=0.1,ethnicityorder=NA,quick=FALSE){
    ### MAIN PLOTTING FUNCTION FOR BARPLOTS
    ## Select the data and associated metadata
    td=as.matrix(data$AC[data$background$non_UK_country==country,])
    tdb=as.matrix(data$background[data$background$non_UK_country==country,])
    rownames(tdb)=rownames(td)=tdb[,1]
    tdb=tdb[tdb[,"ethnicity2"]!="NA",,drop=FALSE]
    td=td[rownames(tdb),]
    ## obtain an ordering for continents and hence populations
    tdsum=matColSums(td,poplist)
    contorder=names(sort(colSums(tdsum),decreasing=TRUE))
    contpoporderlist=lapply(contorder,function(x){
        names(sort(colSums(td[,poplist[[x]]]),decreasing=TRUE))
    })
    poporder=unlist(contpoporderlist)
    ## Obtain an ordering for ethnicities
    if(all(is.na(ethnicityorder))){
        ethnicitylist=lapply(unique(tdb[,"ethnicity2"]),function(x){
            rownames(tdb)[tdb[,"ethnicity2"]==x]
        })
        names(ethnicitylist)=unique(tdb[,"ethnicity2"])
        tm=t(matColMeans(t(td),ethnicitylist))
        ethnicityorder=orderByHclust(tm)
        ethnicityorder=c(ethnicityorder[!ethnicityorder%in%"Mixed"],
                         ethnicityorder[ethnicityorder%in%"Mixed"])
    }else{
        ethnicityorder=ethnicityorder[ethnicityorder%in%unique(tdb[,"ethnicity2"])]
    }
    ## Obtain an ordering for individuals
    indorderlist=lapply(ethnicityorder,function(x){
        tm=td[tdb[,"ethnicity2"]==x,,drop=FALSE]
        contsums=matColSums(tm,poplist)
        ##    corder=colSums(contsums)
        ##tcs=rownames(contsums)[order(contsums[,names(which.max(corder))],decreasing=TRUE)]
        if(dim(contsums)[1]==1) return(rownames(contsums))
        to=orderByHclust(tm)
    })
    indorder=unlist(indorderlist)
    names(indorderlist)=ethnicityorder
### Plot features: location and names of labels
    ninds=sapply(indorderlist,length)
    changes=c(0,cumsum(ninds))
    midpoints=changes[1:(length(changes)-1)] + diff(changes)/2
    names(midpoints)=names(indorderlist)
    names(midpoints)[ninds<labelmin*sum(ninds)]=""
    ## Construction of the plot matrix
    myd=as.matrix(td[indorder,poporder])
    myd=myd/rowSums(myd)
    ## Actual plotting!
    plot(c(0,dim(myd)[1]),c(-0.5,1),xlab="",ylab="",axes=F,type="n")
    par(xpd=TRUE)
    rect(0,-0.5,dim(myd)[1],1.4,col="#FFFFFF88",border=NA)
    par(xpd=FALSE)
    rect(0,-0.5,dim(myd)[1],1.2,col="white",border=NA)
    if(!quick)barplot(t(myd),border=NA,col=mycols2[colnames(myd)],
            axes=FALSE,axisnames=FALSE,space=0,add=T)
    abline(v=changes)
    text(midpoints,rep(-0.25,length(midpoints)),ethnicitynames[names(midpoints)],cex=cex.text)
    mtext(paste0(country," (",dim(myd)[1],")"),side=3,adj=0.1,cex=cex.main)

}

isin=function(trange,xlim,ylim){
    ## Asks if any of trange is inside the rectangle xlim,ylim
    if((
        (trange[2,1]>=xlim[1] && trange[1,1]<=xlim[2]) &&
        (trange[2,2]>=ylim[1] && trange[1,2]<=ylim[2])
     )) return(TRUE)
    return(FALSE)
}
#####################################
## Locations where we will put the barplots
moveit<-function(who,by=NA,to=NA,target=c("tlong","tlat")){
    if(!all(is.na(by))){
        allcountriesdf[who,target] <<-
            allcountriesdf[who,target] + by
    }else if(!all(is.na(to))){
        allcountriesdf[who,target] <<-to
    }
}
############## COLOR THINGS
vividpallette=function(count,seed=1,scale=0.6){
    ## Latin hypercube sampling of RGB space for the central "scale" proportion
    set.seed(seed)
    vals=randomLHS(count, 3)
    vals=vals*scale+(1-scale)/2
    apply(vals,1,function(x){
        rgb(x[1],x[2],x[3])
    })
}
palepallette=function(count,colasvec,colasvec2=c(0,0,0),scale=1,fade=0.3){
    ## Pale palette on a transect from colasvec to colasvec2
    tx=seq(scale/2,1-scale/2,length.out=count)
    sapply(tx,function(x){
        rgb(colasvec2[1]*(1-x)+colasvec[1]*x,
            colasvec2[2]*(1-x)+colasvec[2]*x,
            colasvec2[3]*(1-x)+colasvec[3]*x,fade)
    })
}

#############################################
#############################################
#############################################
#############################################
## START OF DATA PROCESSING

## Read map shape information
map0=map=readRDS("data/ukbres_v2.2/medqmaplist.RDS")

###
## Read agglomeration (mapping of inferred populations to reported populations)
namedf=read.table("data/ukbres_v2.2/surrogateagglomoration.txt",sep="\t",header=T)
namelist=as.list(namedf[,3])
names(namelist)=namedf[,2]
namelistnogb=lapply(namelist,function(x){
    if(substr(x,1,3)=="GB ")return("")
    x})
## Give things nicer names
namelistnogb[["G_SW_Wales"]]="Wales"
namelistnogb[["G_SE_England"]]="England"
namelistnogb[["G_NW_Scot"]]="Scotland"

## Read map shapes for populations
geo= read.csv("data/ukbres_v2.2/127_ancestry_geo.csv",row.names=1)
geo["E_Adygei","group"]="North_Europe"
## geo contains continent and region groupings
## However these need tweaking for visualisation

## Continental structure, which defines our plotting units
mergelist=list(
    "Asia"=c("Central_Asia","South_East_Asia","West_Asia","South_Asia","Siberia"),
    "Africa"=c("Central_Africa","North_Africa","West_Africa","East_Africa","South_Africa"),
    "Pacific_America"=c("Pacific_Islands","native_American"),
    "North_Europe"=c("East_Europe","Middle_Europe","North_Europe"))
## map each of these into simpler structure for visualisation
merge=function(x,m=mergelist){
    mergevals=unlist(m)
    sapply(x,function(y){
        if(y%in% mergevals) {
            i=which(sapply(m,function(mm)y%in%mm))
            return(names(m[i]))
        }else return(y)
    })
}
geo$group2=merge(geo$group)

## represent this structure as a list
poplist=lapply(unique(geo$group2),function(x){
    rownames(geo)[geo$group2==x]
})
names(poplist)=unique(geo$group2)

########
## Checking that all names in our data match names in our map shapes
stopifnot(length(names(namelist)[ !names(namelist) %in% names(map)])==0)
stopifnot(length(names(map)[ !names(map) %in% names(namelist)])==0)

####
## Read the individual-level admixture estimates, the AC data
data=readRDS("data/ukbres_v2.2/ancestry_birth_country_ethnicity.rds")
## contains 2 lists, data$AC is a data frame of N individuals by K populations
## data$background is a data frame of N individuals by describing ID, birth country, and ethnicity
ukdata=data
## Split into UK vs non-UK
ukdata$AC=ukdata$AC[is.na(ukdata$background$non_UK_country),]
ukdata$background=ukdata$background[is.na(ukdata$background$non_UK_country),]
data$AC=data$AC[!is.na(data$background$non_UK_country),]
data$background=data$background[!is.na(data$background$non_UK_country),]
data$background[is.na(data$background[,"ethnicity"]),"ethnicity"]="Prefer not to answer"

## Tidy up ethnicity
ethnicityoldnames=unique(data$background$ethnicity)
ethnicitynewnames=gsub(" background","",gsub("Any other","Other",ethnicityoldnames))
ethnicitynewnames=gsub(" ethnic group","",ethnicityoldnames)
ethnicitynewnames[ethnicitynewnames%in%c("Do not know","Prefer not to answer")]="NA"
ethnicitynewnames[ethnicitynewnames%in%c("Mixed","Other mixed","Any other mixed background")]="Mixed"
ethnicitynewnames[ethnicitynewnames%in%c("Any other white background")]="White"
ethnicitynewnames[ethnicitynewnames%in%c("Any other Black background")]="Black"
ethnicitynewnames[ethnicitynewnames%in%c("Any other Asian background")]="Asian"
ethnicitynewnames=gsub("Black or Black British","Black",ethnicitynewnames)
ethnicitynewnames=gsub("Asian or Asian British","Asian",ethnicitynewnames)
ethnicitynewnames[ethnicitynewnames%in%"Other Asian"]="Asian"
ethnicitynewnames[ethnicitynewnames%in%"White and Black African"]="Mixed"
ethnicitynewnames[ethnicitynewnames%in%"White and Black Caribbean"]="Mixed"
ethnicitynewnames[ethnicitynewnames%in%"White and Asian"]="Mixed"
names(ethnicitynewnames)=ethnicityoldnames
data$background$ethnicity2=ethnicitynewnames[data$background$ethnicity]
table(data$background$ethnicity2)
ethnicitynames=c("British"="Bri",
                 "White"="Whi",
                 "Irish"="Ire",
                 "African"="Afr",
                 "Black"="Blk",
                 "Caribbean"="Car",
                 "Other"="Oth",
                 "Mixed"="Mix",
                 "Indian"="Ind",
                 "Pakistani"="Pa",
                 "Asian"="Asi",
                 "Chinese"="Chi"
        )

## Make a backup, so we can modify as needed
databackup=data
poplistbackup=poplist

## Check that the data match
stopifnot(length(names(map)[ !names(map) %in% colnames(data$AC) ])==0)
stopifnot(length(names(map)[ !colnames(data$AC) %in% names(map) ])==0)

## Get summaries of #samples per country
## We will only report countries that have sufficient people born in them
allcountries=table(data$background$non_UK_country,useNA="always")
allcountries=allcountries[allcountries>=50]

## Matching UKBB countries to map countries
countriesSP <- getMap(resolution='low')
myidx=countriesSP$continent=="Africa"
myidx[is.na(myidx)]=FALSE
## Convert factors to characters
countriesSP$simplename=
    countriesSP$NAME %>% as.character()

## fuzzy string matching between map shape datasets
cmatch=amatch(
    names(allcountries),
    countriesSP$simplename
)
## The countries that didn't just match
names(allcountries)[is.na(cmatch)]
## Make a dataframe of lat/long/continent class for each country
allcountriesdf=data.frame(name=names(allcountries),
           count=as.numeric(allcountries),
           match=countriesSP$simplename[cmatch])
allcountriesdf=cbind(allcountriesdf,
      t(sapply(allcountriesdf$match,function(x){
          if(is.na(x)) {return(c(NA,NA,NA));}
          tw=which(countriesSP$simplename==x)
          c(lat=mean(na.omit(countriesSP[tw,]$LAT)),
            long=mean(na.omit(countriesSP[tw,]$LON)),
            continent=as.character(countriesSP$continent[tw]))
      })))
allcountriesdf$long=as.numeric(allcountriesdf$long)
allcountriesdf$lat=as.numeric(allcountriesdf$lat)
rownames(allcountriesdf)=allcountriesdf[,1]
## Add those that failed automatic matching
allcountriesdf["Caribbean",c("continent")] = "North America"
allcountriesdf["Caribbean",c("lat","long")] = c(19,-73)
allcountriesdf["USA",c("continent")] = "North America"
allcountriesdf["USA",c("lat","long")] = c(33,-100)
allcountriesdf["The Guianas",c("continent")] = "South America"
allcountriesdf["The Guianas",c("lat","long")] = c(10,-64)
allcountriesdf["Serbia/Montenegro",c("continent")] = "Eurasia"
allcountriesdf["Serbia/Montenegro",c("lat","long")] = c(44,20)
allcountriesdf["Gibraltar",c("continent")] = "Eurasia"
allcountriesdf["Gibraltar",c("lat","long")] = c(36.1,-5.3)
allcountriesdf["Czech Republic",c("continent")] = "Eurasia"
allcountriesdf["Czech Republic",c("lat","long")] = c(50,14)
allcountriesdf["Congo",c("continent")] = "Africa"
allcountriesdf["Congo",c("lat","long")] = c(0,15)
allcountriesdf["Channel Islands",c("continent")] = "Eurasia"
allcountriesdf["Channel Islands",c("lat","long")] = c(49.4,-2.6)
allcountriesdf["Palestine",c("continent")] = "Eurasia"
allcountriesdf["Palestine",c("lat","long")] = c(31.65,35.34)
allcountriesdf["Myanmar (Burma)",c("continent")] = "Eurasia"
allcountriesdf["Myanmar (Burma)",c("lat","long")] = c(20,95)
allcountriesdf$olat=allcountriesdf$tlat=allcountriesdf$lat
allcountriesdf$olong=allcountriesdf$tlong=allcountriesdf$long


## Set up color palettes for the world
colslist=list("Africa"=c(1,1,0,0,0,0),
              "Asia"=c(1,0,1,0,0,0),
              "East_Asia"=c(0,1,1,0,0,0),
              "North_Europe"=c(1,0,0,0,0,0),
              "South_Europe"=c(0.5,0,0,0,0.5,0),
              "West_Europe"=c(0.5,0.5,0,0,0,0.5),
              "Pacific_America"=c(0,0,1,0,0,0))
colcount=sapply(names(colslist),function(x)sum(geo$group2==x))
names(colcount)=names(colslist)
rawcols=lapply(names(colcount),function(x){
    ret=palepallette(colcount[[x]],colslist[[x]][1:3],colslist[[x]][4:6])
    names(ret)=rownames(geo)[geo$group2==x]
    ret
})
names(rawcols)=names(colcount)

#############################
#############################
#############################
#############################
#############################
########################
## Africa-specific work
africacountries=allcountriesdf[allcountriesdf[,"continent"]=="Africa","name"]
africacountries=c(africacountries,"Caribbean","Barbados","The Guianas")
## Africa plot
mycols=rawcols
activepallette=vividpallette(colcount[["Africa"]])
mycols[["Africa"]][]=activepallette # Color for each worldwide population, with Africa made vivid (list format)

mycols2=unlist(mycols,use.names=FALSE) # Color for each worldwide population, with Africa made vivid (vector format)
names(mycols2)=unlist(sapply(mycols,names),use.names=FALSE)
## Order to present ethnicity
ethnicityorder=c("African","Black","Caribbean","Other","Mixed",
                 "British","White","Irish",
                 "Indian","Pakistani","Asian","Chinese")
## Set up bounding boxes, positioning information for subplots
xlim=c(-38,68)
ylim=c(-45,42)
dy=10
dx=30
ll=-30; rr=60; tt=37; bb=tt-8*dy ## furthest points allowed
mm=(rr+ll)/2 ## centre of the plot
rpp=15 ## radians per pixed
allcountriesdf$lat=allcountriesdf$olat
allcountriesdf$long=allcountriesdf$olong
moveit("Egypt",to=c(rr,tt))
moveit("Libya",to=c(mm,tt))
moveit("Sudan",to=c(5,tt-dy))
moveit("Algeria",to=c(ll,tt))
moveit("Morocco",to=c(ll,tt-dy))
moveit("Sierra Leone",to=c(ll,tt-2*dy))
moveit("Nigeria",to=c(mm,tt-3*dy))
moveit("Ghana",to=c(ll,tt-3*dy))
moveit("Cameroon",to=c(ll,tt-4*dy))
moveit("Congo",to=c(ll+dx,tt-5*dy))
moveit("Angola",to=c(ll+dx,tt-6*dy))
moveit("Zambia",to=c(ll+dx,tt-7*dy))
moveit("Caribbean",to=c(ll,tt-6*dy))
moveit("Barbados",to=c(ll,tt-7*dy))
moveit("The Guianas",to=c(ll,tt-8*dy))
##
moveit("South Africa",to=c(rr-2*dx,tt-8*dy))
moveit("Zimbabwe",to=c(rr-dx,tt-8*dy))
moveit("Malawi",to=c(rr,tt-8*dy))
moveit("Tanzania",to=c(rr,tt-7*dy))
moveit("Mauritius",to=c(rr,tt-6*dy))
moveit("Uganda",to=c(rr,tt-5*dy))
moveit("Kenya",to=c(rr,tt-4*dy))
moveit("Somalia",to=c(rr,tt-3*dy))
moveit("Ethiopia",to=c(rr,tt-2*dy))
moveit("Eritrea",to=c(rr,tt-dy))
moveit("Sudan",to=c(mm,20))
moveit("Caribbean",to=c(ll,tt-6*dy),target=c("long","lat"))
moveit("Barbados",to=c(ll,tt-7*dy),target=c("long","lat"))
moveit("The Guianas",to=c(ll,tt-8*dy),target=c("long","lat"))

##########################
png("Africa.png",height=diff(ylim)*rpp,width=diff(xlim)*rpp)
## Define general properties
figsize=c(5,1.25)
cex.ancestry=1.5
cex.text.barplot=1.2
cex.main.barplot=1.5
addcoords = FALSE
gridcoords=expand.grid(seq(ylim[1],ylim[2],by=5),
                       seq(xlim[1],xlim[2],by=5))
## Empty plot
plot(c(0,0),c(0,0),type="n",axes=FALSE,xlab="",ylab="",xlim=xlim,ylim=ylim,asp=1)
## Background colour for the sea
rect(xlim[1]-10,ylim[1]-10,xlim[2]+10,ylim[2]+10,col="#EEEEFF")
## Plot the map shapes for ancestries
for(i in 1:length(map)){
    trange=apply(map[[i]],2,function(x)range(na.omit(x)))
    if(isin(trange,xlim+c(-10,10),ylim+c(-10,10))) {
        print(paste("plotting",names(map)[[i]]))
        polygon(map[[i]],col=mycols2[names(map)[i]],border=NA)
    }
}
## Add the country shapes
plot(countriesSP, add=TRUE,border=c("white"))
## Add the names for the ancestry populations
for(i in 1:length(map)){
    trange=apply(map[[i]],2,function(x)range(na.omit(x)))
    if(isin(trange,xlim,ylim)) {
        tx=colMeans(na.omit(map[[i]]))
        text(tx[1],tx[2],namelist[[names(map)[i]]],font=3,
             cex=cex.ancestry,col="#222222")
    }
}
## Plot the UKBB results
for(x in africacountries){
    i=which(allcountriesdf$name==x)
    figpos=allcountriesdf[i,c("tlong","tlat")]
    if(isin(rbind(figpos,figpos),xlim,ylim)) {
        print(paste("Plotting country",x))
        lines(allcountriesdf[i,c("long","tlong")],
              allcountriesdf[i,c("lat","tlat")],col="white",lwd=3)
        subplot(dobarplot(x,
                          cex.text=cex.text.barplot,
                          cex.main=cex.main.barplot,
                          ethnicityorder=ethnicityorder),
                figpos[1],figpos[2],size=figsize)
    }else{
        print(paste("OMITTING country",x))
    }
}
## optionally, add the grid for easier placement
if(addcoords){
    text(gridcoords[,2],gridcoords[,1],
         apply(gridcoords,1,function(x)paste((x),collapse=",")),
         cex=0.5)
}
dev.off()



#############################
#############################
#############################
#############################
#############################
## Europe plot
poplist=poplistbackup
data=databackup
europecountries=allcountriesdf[,"name"]
tw=sapply(europecountries,function(x){
    figpos=allcountriesdf[x,c("long","lat")]
    isin(rbind(figpos,figpos),c(-10,50),c(30,70))
})
europecountries=europecountries[tw]
europecountries=europecountries[!europecountries%in%c("Lebanon","Palestine","Iraq","Israel")]
europecountries=c(europecountries,"Russia")
## Colors
mycols=rawcols
activepallette=vividpallette(colcount[["North_Europe"]]+
                             colcount[["South_Europe"]]+
                             colcount[["West_Europe"]] -
                                sum(geo$country=="United Kingdom") + 4,
                             seed=2)
mycols2=unlist(mycols,use.names=FALSE)
names(mycols2)=unlist(sapply(mycols,names),use.names=FALSE)
england=c(1:10,13,15,16,17,19,20)
scotland=c(11,18,21)
wales=c(10,12,14)
ireland=c(22,23)
othernw=24:30
mycols2[poplist$West_Europe[england]]=activepallette[1]
mycols2[poplist$West_Europe[scotland]]=activepallette[2]
mycols2[poplist$West_Europe[wales]]=activepallette[3]
mycols2[poplist$West_Europe[ireland]]=activepallette[4]
mycols2[poplist$West_Europe[othernw]]=activepallette[5:11]
mycols2[poplist$South_Europe]=activepallette[12:24]
mycols2[poplist$North_Europe]=activepallette[25:40]
mycols2["England"]=activepallette[1]
mycols2["Scotland"]=activepallette[2]
mycols2["Wales"]=activepallette[3]
mycols2["Ireland"]=activepallette[4]
mycols2["E_Russian"]=activepallette[41]

## this section sums over UK countries to make merged populations that are not merged in the raw data
makesimpledata=FALSE
if((!exists("datasimple")) || makesimpledata){
    poplist=poplistbackup
    poplist2=poplist
    poplist2$West_Europe[england]
    poplist2ul=list("England"=poplist2$West_Europe[england],
                    "Scotland"=poplist2$West_Europe[scotland],
                    "Wales"=poplist2$West_Europe[wales],
                    "Ireland"=poplist2$West_Europe[ireland])
    poplistsimple=list("West_Europe"=c(names(poplist2ul),poplist2$West_Europe[othernw]))
    poplistsimple[2:length(poplist)]=poplist[2:length(poplist)]
    names(poplistsimple)=names(poplist)
    poplist2ul[poplist2$West_Europe[othernw]]=poplist2$West_Europe[othernw]
    for(p in 2:length(poplist)) poplist2ul[poplist2[[p]]]=poplist2[[p]]
    data=databackup
    data$AC=matColSums(data$AC,poplist2ul)
    datasimple=data
    poplist=poplistsimple
}else{
    data=datasimple
    poplist=poplistsimple
}

## Order to present ethnicity
ethnicityorder=c(
    "White","Other","British","Irish",
    "African","Black","Caribbean","Mixed",
    "Indian","Pakistani","Asian","Chinese")
xlim=c(-15,45)
ylim=c(32,68)
ll=-13; rr=ll+4*dx; tt=65; bb=tt-8*dy ## furthest points allowed
mm=(rr+ll)/2 ## centre of the plot
rpp=25 ## radians per pixel
dy=5
dx=13.5
allcountriesdf$lat=allcountriesdf$olat
allcountriesdf$long=allcountriesdf$olong
moveit("United Kingdom",to=c(ll,tt-dy))
moveit("Channel Islands",to=c(ll,tt-2*dy))
moveit("France",to=c(ll,tt-3*dy))
moveit("Spain",to=c(ll,tt-4*dy))
moveit("Portugal",to=c(ll,tt-5*dy))
moveit("Gibraltar",to=c(ll,tt-6*dy))
##
moveit("Norway",to=c(ll+dx,tt-0.5*dy))
moveit("Sweden",to=c(ll+2*dx,tt))
moveit("Denmark",to=c(ll+dx,tt-1.5*dy))
moveit("Finland",to=c(ll+3*dx,tt-0.5*dy))
moveit("Latvia",to=c(ll+3*dx,tt-1.5*dy))
moveit("Lithuania",to=c(ll+4*dx,tt-2*dy))
moveit("Poland",to=c(ll+2*dx,tt-dy))
moveit("Ukraine",to=c(ll+4*dx,tt-3*dy))
moveit("Romania",to=c(ll+4*dx,tt-4*dy))
moveit("Turkey",to=c(ll+4*dx,tt-5*dy))
moveit("Cyprus",to=c(ll+3*dx,tt-5.5*dy))
moveit("Israel",to=c(ll+4*dx,tt-6*dy))
##
moveit("Hungary",to=c(ll+3*dx,tt-2.5*dy))
moveit("Serbia/Montenegro",to=c(ll+3*dx,tt-3.5*dy))
moveit("Bulgaria",to=c(ll+3*dx,tt-4.5*dy))
moveit("Greece",to=c(ll+2*dx,tt-6*dy))
moveit("Malta",to=c(ll+dx,tt-5.5*dy))
##
moveit("Italy",to=c(ll+2*dx,tt-5*dy))
moveit("Switzerland",to=c(ll+dx,tt-4.5*dy))
##
moveit("Netherlands",to=c(ll+dx,tt-2.5*dy))
moveit("Belgium",to=c(ll+dx,tt-3.5*dy))
moveit("Germany",to=c(ll+2*dx,tt-2*dy))
moveit("Czech Republic",to=c(ll+2*dx,tt-3*dy))
moveit("Austria",to=c(ll+2*dx,tt-4*dy))
moveit("Russia",to=c(rr,tt-dy))
## Move where the labels point to
moveit("Spain",to=c(-3.6,43),target=c("long","lat"))
moveit("Lithuania",to=c(25,55.32),target=c("long","lat"))
moveit("Norway",to=c(10,60),target=c("long","lat"))
moveit("Poland",to=c(20,55),target=c("long","lat"))
moveit("Germany",to=c(10,53),target=c("long","lat"))
moveit("Russia",to=c(35,57),target=c("long","lat"))

png("Europe.png",height=diff(ylim)*rpp,width=diff(xlim)*rpp)
## Define general properties
figsize=c(3,0.8)
cex.ancestry=1.1
cex.text.barplot=1
cex.main.barplot=1.1
addcoords = FALSE
quick=FALSE
gridcoords=expand.grid(seq(ylim[1],ylim[2],by=5),
                       seq(xlim[1],xlim[2],by=5))
## Empty plot
plot(c(0,0),c(0,0),type="n",axes=FALSE,xlab="",ylab="",xlim=xlim,ylim=ylim,asp=1)
## Background colour for the sea
rect(xlim[1]-10,ylim[1]-10,xlim[2]+10,ylim[2]+10,col="#EEEEFF")
## Plot the map shapes for ancestries
for(i in 1:length(map)){
    trange=apply(map[[i]],2,function(x)range(na.omit(x)))
    if(isin(trange,xlim+c(-10,10),ylim+c(-10,10))) {
        print(paste("plotting",names(map)[[i]]))
        polygon(map[[i]],col=mycols2[names(map)[i]],border=NA)
    }
}
## Add the country shapes
plot(countriesSP, add=TRUE,border=c("white"))
## Add the names for the ancestry populations
for(i in 1:length(map)){
    trange=apply(map[[i]],2,function(x)range(na.omit(x)))
    if(isin(trange,xlim,ylim)) {
        tx=colMeans(na.omit(map[[i]]))
        text(tx[1],tx[2],namelistnogb[[names(map)[i]]],font=3,
             cex=cex.ancestry,col="#222222")
    }
}
## Plot the UKBB results
for (pass in 1:2) for(x in europecountries){ 
    i=which(allcountriesdf$name==x)
    figpos=allcountriesdf[i,c("tlong","tlat")]
    if(!isin(rbind(figpos,figpos),xlim,ylim)) {
        print(paste("OMITTING country",x))
        next;
    }
    if(pass==1){lines(allcountriesdf[i,c("long","tlong")],
                      allcountriesdf[i,c("lat","tlat")],col="white",lwd=3)
    }else if(pass==2){
        print(paste("Plotting country",x))
        subplot(dobarplot(x,
                          cex.text=cex.text.barplot,
                          cex.main=cex.main.barplot,
                          ethnicityorder=ethnicityorder,quick=quick),
                figpos[1],figpos[2],size=figsize)
    }
}
## optionally, add the grid for easier placement
if(addcoords){
    text(gridcoords[,2],gridcoords[,1],
         apply(gridcoords,1,function(x)paste((x),collapse=",")),
         cex=0.5)
}
dev.off()


#############################
#############################
#############################
#############################
#############################
########################
## Asia-specific work
## centralcountries=allcountriesdf[allcountriesdf[,"continent"]=="Eurasia","name"]
## Asia plot
poplist=poplistbackup
data=databackup
asiacountries=allcountriesdf[,"name"]
tw=sapply(asiacountries,function(x){
    figpos=allcountriesdf[x,c("long","lat")]
    isin(rbind(figpos,figpos),c(30,140),c(-20,70))
})
asiacountries=asiacountries[tw]
asiacountries=asiacountries[!asiacountries%in%
                                  c("Cyprus","Ukraine","Eritrea","Ethiopia","Kenya","Uganda","Somalia","Tanzania","Malawi","Russia")]
asiacountries=c(asiacountries,"Australia","New Zealand","Kenya","Uganda","Mauritius","Tanzania","Malawi")

mycols=rawcols
activepallette=vividpallette(colcount[["Asia"]]+colcount[["East_Asia"]],seed=2)
mycols[["Asia"]][]=activepallette[1:colcount[["Asia"]]]
mycols[["East_Asia"]][]=activepallette[colcount[["Asia"]]+(1:colcount[["East_Asia"]])]
mycols2=unlist(mycols,use.names=FALSE)
names(mycols2)=unlist(sapply(mycols,names),use.names=FALSE)
mycols2["W_Balochi"]="#BBBB33"
mycols2["W_NAN_Melanesian"]="#FF33FF"
mycols2["W_Malaysia"]="#33FFFF"
mycols2["W_Myanmar"]="#FF3333"
mycols2["W_CHD_2"]="#3333FF"
mycols2["W_Bangladesh"]="#5588CC"
mycols2["W_Bedouin_2"]="#B2FFCA"
    
## Order to present ethnicity
ethnicityorder=c("Indian","Pakistani","Asian","Chinese","Other","Mixed",
                 "British","White","Irish",
                 "African","Black","Caribbean")
xlim=c(30,140)
ylim=c(-15,55)
dy=10
dx=20
ll=35; rr=ll+5*dx; tt=50; bb=tt-6*dy ## furthest points allowed
mm=(rr+ll)/2 ## centre of the plot
rpp=15 ## radians per pixed
#############
## Placement
allcountriesdf$lat=allcountriesdf$olat
allcountriesdf$long=allcountriesdf$olong
moveit("Turkey",to=c(ll,tt))
moveit("Palestine",to=c(ll,tt-dy))
moveit("Israel",to=c(ll,tt-2*dy))
moveit("Lebanon",to=c(ll,tt-3*dy))
moveit("Iraq",to=c(ll+dx,tt))
moveit("Iran",to=c(ll+dx,tt-2*dy))
moveit("Afghanistan",to=c(ll+2*dx,tt))
moveit("Pakistan",to=c(ll+dx,tt-3*dy))
moveit("Yemen",to=c(ll+dx,bb+2*dy))
moveit("Myanmar (Burma)",to=c(ll+3*dx,tt-3*dy))
moveit("Nepal",to=c(ll+3*dx,tt-dy))
moveit("Bangladesh",to=c(ll+3*dx,tt-2*dy))
moveit("India",to=c(ll+2*dx,tt-3*dy))
##
moveit("Japan",to=c(rr,tt-dy))
moveit("China",to=c(rr-dx,tt-2*dy))
moveit("Hong Kong",to=c(rr-dx,tt-3*dy))
moveit("Philippines",to=c(rr,tt-3*dy))
moveit("Vietnam",to=c(rr-dx,tt-4*dy))
moveit("Thailand",to=c(rr-2*dx,tt-4*dy))
moveit("Sri Lanka",to=c(rr-3*dx,tt-4*dy))
moveit("Malaysia",to=c(rr,tt-4*dy))
moveit("Indonesia",to=c(rr-dx,tt-5*dy))
moveit("Singapore",to=c(rr-2*dx,tt-5*dy))
##
moveit("Australia",to=c(rr-dx,bb))
moveit("Australia",to=c(rr-dx,bb),target=c("long","lat"))
moveit("New Zealand",to=c(rr,bb))
moveit("New Zealand",to=c(rr,bb),target=c("long","lat"))
moveit("Kenya",to=c(ll,tt-4*dy))
moveit("Uganda",to=c(ll,tt-5*dy))
moveit("Tanzania",to=c(ll,tt-6*dy))
moveit("Malawi",to=c(ll+dx,tt-6*dy))
moveit("Mauritius",to=c(ll+2*dx,tt-6*dy))



## plot for extended data figure 2 (this version is overly complicated and has a less pleasing layout than the main paper figure)
png("Asia.png",height=diff(ylim)*rpp,width=diff(xlim)*rpp)
## Define general properties
figsize=c(3.3,0.9)
cex.ancestry=1.1
cex.text.barplot=1
cex.main.barplot=1.1
addcoords = FALSE
quick=FALSE
gridcoords=expand.grid(seq(ylim[1],ylim[2],by=5),
                       seq(xlim[1],xlim[2],by=5))
## Empty plot
plot(c(0,0),c(0,0),type="n",axes=FALSE,xlab="",ylab="",xlim=xlim,ylim=ylim,asp=1)
## Background colour for the sea
rect(xlim[1]-10,ylim[1]-10,xlim[2]+10,ylim[2]+10,col="#EEEEFF")
## Plot the map shapes for ancestries
for(i in 1:length(map)){
    trange=apply(map[[i]],2,function(x)range(na.omit(x)))
    if(isin(trange,xlim+c(-10,10),ylim+c(-10,10))) {
        print(paste("plotting",names(map)[[i]]))
        polygon(map[[i]],col=mycols2[names(map)[i]],border=NA)
    }
}
## Add the country shapes
plot(countriesSP, add=TRUE,border=c("white"))
## Add the names for the ancestry populations
for(i in 1:length(map)){
    trange=apply(map[[i]],2,function(x)range(na.omit(x)))
    if(isin(trange,xlim,ylim)) {
        tx=apply(na.omit(map[[i]]),2,median)
        text(tx[1],tx[2],namelistnogb[[names(map)[i]]],font=3,
             cex=cex.ancestry,col="#222222")
    }
}
## Plot the UKBB results
for (pass in 1:2) for(x in asiacountries){ 
    i=which(allcountriesdf$name==x)
    figpos=allcountriesdf[i,c("tlong","tlat")]
    if(!isin(rbind(figpos,figpos),xlim,ylim)) {
        print(paste("OMITTING country",x))
        next;
    }
    if(pass==1){lines(allcountriesdf[i,c("long","tlong")],
                      allcountriesdf[i,c("lat","tlat")],col="white",lwd=3)
    }else if(pass==2){
        print(paste("Plotting country",x))
        subplot(dobarplot(x,
                          cex.text=cex.text.barplot,
                          cex.main=cex.main.barplot,
                          ethnicityorder=ethnicityorder,quick=quick),
                figpos[1],figpos[2],size=figsize)
    }
}
## optionally, add the grid for easier placement
if(addcoords){
    text(gridcoords[,2],gridcoords[,1],
         apply(gridcoords,1,function(x)paste((x),collapse=",")),
         cex=0.5)
}
dev.off()

#############################
#############################
#############################
#############################
#############################
#############################
#############################
#############################
#############################
## Main Figure plot
figorder=c("Turkey","Iraq","Iran","Afghanistan","Pakistan","Nepal","Japan",
           "China","Hong Kong","Vietnam","Philippines","Malaysia","Indonesia",
           "New Zealand","Australia",
           "Singapore","Thailand","Bangladesh", 
           "Mauritius","Malawi","Tanzania","Uganda","Kenya",
           "Yemen","Israel","Lebanon")
#"Sri Lanka","India","Myanmar (Burma)"
figorder[!figorder%in%asiacountries]
asiacountries[!asiacountries%in%figorder]
xlim=c(20,160)
ylim=c(-20,55)
nx=6
ny=8
dx=(diff(xlim))/(nx)
dy=(diff(ylim)+10)/ny
ll=20; tt=55; ## furthest points allowed
rpp=15 ## radians per pixel
for(i in 1:length(figorder)){
    if(i<=nx) {
        lnew=ll+(i-1)*dx
        tnew=tt
    }else if(i<nx+ny){
        lnew=ll+nx*dx
        tnew=tt-(i-nx-1)*dy
    }else if(i<=2*nx+ny){
        lnew=ll+((2*nx+ny)-i)*dx
        tnew=tt-dy*(ny-1)
    }else if(i<=2*nx+2*ny-1){
        lnew=ll
        tnew=tt-dy*(2*nx+2*ny-i-1)
    }else{
        stop("PANIC! Out of space")
    }
    print(paste(figorder[i],i,lnew,tnew))
    moveit(figorder[i],to=c(lnew,tnew))
}
moveit("China",to=c(115,30),target=c("long","lat"))
moveit("New Zealand",to=c(160,-20),target=c("long","lat"))
moveit("Australia",to=c(140,-20),target=c("long","lat"))
figorder=c(figorder,"India","Sri Lanka","Myanmar (Burma)")
moveit("India",to=c(ll+2*dx,tt-5*dy))
moveit("Sri Lanka",to=c(ll+2*dx,tt-6*dy))
moveit("Myanmar (Burma)",to=c(ll+3*dx,tt-6*dy))
##
contcols=sapply(rawcols,function(x)as.character(x[1]))
##
ethnicitydf=data.frame(index=names(ethnicitynames),name=ethnicitynames)
ethnicitydf["Other","index"]="Other Ethnic Group"

png("AsiaMainFigure.png",height=diff(ylim)*rpp,width=diff(xlim)*rpp)
## Define general properties
figsize=c(3.8,1.5)
cex.ancestry=1.3
cex.text.barplot=1.5
cex.main.barplot=1.5
addcoords = FALSE
quick=FALSE
gridcoords=expand.grid(seq(ylim[1],ylim[2],by=5),
                       seq(xlim[1],xlim[2],by=5))
## Empty plot
plot(c(0,0),c(0,0),type="n",axes=FALSE,xlab="",ylab="",xlim=xlim,ylim=ylim,asp=1)
## Background colour for the sea
rect(xlim[1]-10,ylim[1]-10,xlim[2]+10,ylim[2]+10,col="#EEEEFF")
## Plot the map shapes for ancestries
for(i in 1:length(map)){
    trange=apply(map[[i]],2,function(x)range(na.omit(x)))
    if(isin(trange,xlim+c(-10,10),ylim+c(-10,10))) {
        polygon(map[[i]],col=mycols2[names(map)[i]],border="NA")
    }
}
## Add the country shapes
plot(countriesSP, add=TRUE,border=c("white"))
par(xpd=NA)
rect(xlim[1]-20,ylim[1]-20,xlim[1],ylim[2]+20,col="white",border="NA")
rect(xlim[1]-20,ylim[2],xlim[2]+20,ylim[2]+20,col="white",border="NA")
rect(xlim[2],ylim[1]-20,xlim[2]+20,ylim[2]+2,col="white",border="NA")
rect(xlim[1]-20,ylim[1]-20,xlim[2]+20,ylim[1],col="white",border="NA")
par(xpd=FALSE)
## Plot the UKBB results
for (pass in 1:2) for(x in figorder){ 
    i=which(allcountriesdf$name==x)
    figpos=allcountriesdf[i,c("tlong","tlat")]
    ## if(!isin(rbind(figpos,figpos),xlim,ylim)) {
    ##     print(paste("OMITTING country",x))
    ##     next;
    ## }
    if(pass==1){lines(allcountriesdf[i,c("long","tlong")],
                      allcountriesdf[i,c("lat","tlat")],col="white",lwd=4)
    }else if(pass==2){
        print(paste("Plotting country",x))
        subplot(dobarplot(x,
                          cex.text=cex.text.barplot,
                          cex.main=cex.main.barplot,
                          ethnicityorder=ethnicityorder,quick=quick),
                figpos[1],figpos[2],size=figsize)
    }
}
## optionally, add the grid for easier placement
if(addcoords){
    text(gridcoords[,2],gridcoords[,1],
         apply(gridcoords,1,function(x)paste((x),collapse=",")),
         cex=0.5)
}
## Colour Key for continents
rll=ll+dx/2; rtt=tt-dy*4.5
kdy=3.5; rdx=5
rect(rll,rtt,
     rll+dx,tt-dy*6.4,
     col="#FFFFFF66",border="#888888")
cnames=names(contcols)[!names(contcols)%in%c("Asia","East_Asia")]
text(rll+1,rtt-1.5,labels="Worldwide Ancestry:", cex=1.8,adj=0)
for(i in 1:length(cnames)){
    x=cnames[i]
    rect(rll+1,rtt-i*kdy,rll+1+rdx,rtt-i*kdy-2,col="white")
    rect(rll+1,rtt-i*kdy,rll+1+rdx,rtt-i*kdy-2,col=contcols[x])
    text(rll+1+rdx+1,rtt-i*kdy-1,adj=0,labels=gsub("_"," ",x),cex=1.5)
}
par(xpd=NA)
mtext(paste0("Ethnicity Key: Europe: ",
             paste(paste(ethnicitydf[1:3,2],ethnicitydf[1:3,1],sep="="),
                   collapse=", ")),1,1.2,cex=1.5,adj=0)
mtext(paste0("Asia: ",
             paste(paste(ethnicitydf[12:7,2],ethnicitydf[12:7,1],sep=":"),
                   collapse=", ")),1,1.2,cex=1.5,adj=0.5)
mtext(#paste0("African: ",
             paste(paste(ethnicitydf[4,2],ethnicitydf[4,1],sep=":"),
                   collapse=", ")#)
,1,1.2,cex=1.5,adj=1)
dev.off()

#############################
#############################
#############################
#############################
#############################
#############################
#############################
#############################
#############################


#############################
#############################
#############################
#############################
#############################
########################
## America-specific work
## americacountries=allcountriesdf[allcountriesdf[,"continent"]=="Eurasia","name"]
## America plot
poplist=poplistbackup
data=databackup
americacountries=allcountriesdf[allcountriesdf[,"continent"]%in%c("North America","South America"),"name"]

## Check we have all countries now:
allcountriesdf[,"name"][
    (!allcountriesdf[,"name"]%in%africacountries) &
    (!allcountriesdf[,"name"]%in%europecountries) &
    (!allcountriesdf[,"name"]%in%asiacountries) &
    (!allcountriesdf[,"name"]%in%americacountries)]

mycols=rawcols
activepallette=vividpallette(colcount[["Pacific_America"]]+6,seed=2)
mycols[["Pacific_America"]][]=activepallette[1:colcount[["Pacific_America"]]]
for(i in 1:6) mycols[[i]][]=activepallette[colcount[["Pacific_America"]]+i]
mycols2=unlist(mycols,use.names=FALSE)
names(mycols2)=unlist(sapply(mycols,names),use.names=FALSE)
## mycols2=sapply(mycols2,substr,1,7)

## Order to present ethnicity
ethnicityorder=c("British","White","Irish",
                 "African","Black","Caribbean","Other","Mixed",
                 "Indian","Pakistani","Asian","Chinese"
                 )
xlim=c(-110,30)
ylim=c(-40,60)
dy=13
dx=25
ll=-100; rr=ll+5*dx; tt=50; bb=tt-6*dy ## furthest points allowed
mm=(rr+ll)/2 ## centre of the plot
rpp=15 ## radians per pixed
#############
## Placement
allcountriesdf$lat=allcountriesdf$olat
allcountriesdf$long=allcountriesdf$olong
moveit("Canada",to=c(ll,tt))
moveit("USA",to=c(ll,tt-dy))
moveit("Mexico",to=c(ll,tt-2*dy))
moveit("Colombia",to=c(ll,bb+2*dy))
moveit("Peru",to=c(ll,bb+dy))
moveit("Chile",to=c(ll,bb))
moveit("Argentina",to=c(mm,bb))
##
moveit("Caribbean",to=c(mm,tt-dy))
moveit("Barbados",to=c(mm,tt-2*dy))
moveit("The Guianas",to=c(mm,tt-3*dy))
moveit("Venezuela",to=c(mm,tt-4*dy))
moveit("Brazil",to=c(mm,tt-5*dy))

## Main plot
png("America.png",height=diff(ylim)*rpp,width=diff(xlim)*rpp)
## Define general properties
figsize=c(6,1.5)
cex.ancestry=1
cex.text.barplot=1.2
cex.main.barplot=1.5
addcoords = FALSE
quick=FALSE
gridcoords=expand.grid(seq(ylim[1],ylim[2],by=5),
                       seq(xlim[1],xlim[2],by=5))
## Empty plot
plot(c(0,0),c(0,0),type="n",axes=FALSE,xlab="",ylab="",xlim=xlim,ylim=ylim,asp=1)
## Background colour for the sea
rect(xlim[1]-10,ylim[1]-10,xlim[2]+10,ylim[2]+10,col="#EEEEFF")
## Plot the map shapes for ancestries
for(i in 1:length(map)){
    trange=apply(map[[i]],2,function(x)range(na.omit(x)))
    if(isin(trange,xlim+c(-10,10),ylim+c(-10,10))) {
        polygon(map[[i]],col=mycols2[names(map)[i]],border=NA)
    }
}
## Add the country shapes
plot(countriesSP, add=TRUE,border=c("white"))
## Add the names for the ancestry populations
for(i in 1:length(map)){
    trange=apply(map[[i]],2,function(x)range(na.omit(x)))
    if(isin(trange,xlim,ylim)) {
        tx=colMeans(na.omit(map[[i]]))
        text(tx[1],tx[2],namelistnogb[[names(map)[i]]],font=3,
             cex=cex.ancestry,col="#222222")
    }
}
## Plot the UKBB results
for (pass in 1:2) for(x in americacountries){ 
    i=which(allcountriesdf$name==x)
    figpos=allcountriesdf[i,c("tlong","tlat")]
    if(!isin(rbind(figpos,figpos),xlim,ylim)) {
        print(paste("OMITTING country",x))
        next;
    }
    if(pass==1){lines(allcountriesdf[i,c("long","tlong")],
                      allcountriesdf[i,c("lat","tlat")],col="white",lwd=3)
    }else if(pass==2){
        print(paste("Plotting country",x))
        subplot(dobarplot(x,
                          cex.text=cex.text.barplot,
                          cex.main=cex.main.barplot,
                          ethnicityorder=ethnicityorder,quick=quick),
                figpos[1],figpos[2],size=figsize)
    }
}
## optionally, add the grid for easier placement
if(addcoords){
    text(gridcoords[,2],gridcoords[,1],
         apply(gridcoords,1,function(x)paste((x),collapse=",")),
         cex=0.5)
}
par(xpd=NA)
mtext(paste0("Ethnicity Key: Europe: ",
             paste(paste(ethnicitydf[1:3,2],ethnicitydf[1:3,1],sep="="),
                   collapse=", ")),1,1.2,cex=1.5,adj=0)
mtext(paste0("Asia: ",
             paste(paste(ethnicitydf[12:8,2],ethnicitydf[12:8,1],sep=":"),
                   collapse=", ")),1,1.2,cex=1.5,adj=0.4)
mtext(paste0("African: ",
             paste(paste(ethnicitydf[c(4,6),2],ethnicitydf[c(4,6),1],sep=":"),
                   collapse=", ")),1,1.2,cex=1.5,adj=0.7)
mtext(paste(ethnicitydf[7,2],ethnicitydf[7,1],sep=":"),1,1.2,cex=1.5,adj=1)
dev.off()

########## Make a CSV summary of all results

allmeans=lapply(allcountriesdf$name,function(country){
    res=lapply(names(ethnicitynames),function(eth){
        tw=which((data$background$non_UK_country==country)&(data$background$ethnicity2==eth))
        if(length(tw)>0){
            c(count=length(tw),colMeans(data$AC[tw,,drop=FALSE]))
        }
    })
    names(res)=paste0(country,"_",names(ethnicitynames))
    do.call("rbind",res)
})
names(allmeans)=allcountriesdf$name
allmeansdf=do.call("rbind",allmeans)
allmeansdf=allmeansdf[allmeansdf[,"count"]>=10,]
write.csv(allmeansdf,file="ACs_by_country_and_ethnicity.csv",quote=FALSE)
